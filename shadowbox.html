<!doctype html>
<html lang="en">
<head>
	<title>Camera Texture (Three.js)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<!--<link rel=stylesheet href="css/base.css"/>-->
</head>
<body>

<!--<script src="libs/experiment/Three.js"></script>-->
<script src="libs/three/three.min.js"></script>

<script src="libs/three/threex.basiclighting.js"></script>
<script src="libs/three/OrbitControls.js"></script>

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>

// standard global variables
var container, scene, renderer, controls, stats;
var clock = new THREE.Clock();

// custom global variables
var MovingCube, plane;
var backCamera, leftCamera, bottomCamera, mainCamera;

// intermediate scene for reflecting the reflection
var screenScene, screenCamera, firstRenderTarget, bottomRenderTarget, backRenderTarget, leftRenderTarget;
var gridXZ, gridYZ, gridXY;

init();
animate();
// FUNCTIONS 		
function init() 
{
	// SCENE
	scene = new THREE.Scene();
	// CAMERAS
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 10, FAR = 20000;

	// camera 1
	mainCamera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR );
	scene.add(mainCamera);
	mainCamera.position.set(0,200,500);
	mainCamera.lookAt(scene.position);

	// camera 2
	backCamera = new THREE.OrthographicCamera(
		window.innerWidth  / -2, window.innerWidth  /  2,
		window.innerHeight /  2, window.innerHeight / -2,
		10, 800 );

    backCamera.up.set(0, 1, 0);
    backCamera.position.set(0,0, -400);
	backCamera.lookAt(scene.position);
	scene.add(backCamera);

	// camera 3
	leftCamera = new THREE.OrthographicCamera(
		window.innerWidth  / -2, window.innerWidth  /  2,
		window.innerHeight /  2, window.innerHeight / -2,
		10, 800 );

    leftCamera.up.set(0, 1, 0);
    leftCamera.position.set(-400,0,0);
	leftCamera.lookAt(scene.position);
	scene.add(leftCamera);

	// camera 4
	bottomCamera = new THREE.OrthographicCamera(
		window.innerWidth  / -2, window.innerWidth  /  2,
		window.innerHeight /  2, window.innerHeight / -2,
		10, 800 );

    bottomCamera.up.set(0, 1, 0);
    bottomCamera.position.set(0,-400,0);
	bottomCamera.lookAt(scene.position);
	scene.add(bottomCamera);

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setClearColor("#cecece" );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
//    renderer.sortObjects = false;
//    renderer.shadowMapEnabled = true;
    renderer.shadowMapType = THREE.PCFShadowMap;

	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	// EVENTS

    // creating scene light
    var lighting = new THREEx.ThreePointsLighting();
    scene.add(lighting);

	// FLOOR
    var axes = new THREE.AxisHelper(300);
    scene.add( axes );

    gridXZ = new THREE.GridHelper(400, 100);
    gridXZ.setColors( new THREE.Color(0x006600), new THREE.Color(0x006600) );
    gridXZ.position.set( 0,0,0 );
    scene.add(gridXZ);

    gridXY = new THREE.GridHelper(400, 100);
    gridXY.position.set( 0,0,0 );
    gridXY.rotation.x = Math.PI/2;
    gridXY.setColors( new THREE.Color(0x000066), new THREE.Color(0x000066) );
    scene.add(gridXY);


    gridYZ = new THREE.GridHelper(400, 100);
    gridYZ.position.set( 0,0,0 );
    gridYZ.rotation.z = Math.PI/2;
    gridYZ.setColors( new THREE.Color(0x660000), new THREE.Color(0x660000) );
    scene.add(gridYZ);
	////////////
	// CUSTOM //
	////////////
	
	// create an array with six textures for a cool cube
    var cubeGeometry = new THREE.BoxGeometry( 50, 50, 50 );
    var cubeMaterial = new THREE.MeshPhongMaterial( { color:0xff0000 } );
    MovingCube = new THREE.Mesh( cubeGeometry, cubeMaterial );
	MovingCube.position.set(0, 0, 0);
	scene.add( MovingCube );	

	var wireMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: false, transparent: false } );

    // torus knot
	var colorMaterial = new THREE.MeshPhongMaterial( { color: 0xff3333 } );
	var shape = THREE.SceneUtils.createMultiMaterialObject(
		new THREE.TorusKnotGeometry( 30, 6, 160, 10, 2, 5 ), [ colorMaterial, wireMaterial ] );
	shape.position.set(-150, 150, -200);
	scene.add( shape );

	// torus knot
	var colorMaterial = new THREE.MeshPhongMaterial( { color: 0xff3333 } );
	var shape = THREE.SceneUtils.createMultiMaterialObject( 
		new THREE.TorusKnotGeometry( 30, 6, 160, 10, 2, 5 ), [ colorMaterial, wireMaterial ] );
	shape.position.set(-150, 150, -200);
	scene.add( shape );

	// torus knot
	var colorMaterial = new THREE.MeshPhongMaterial( { color: 0x33ff33 } );
	var shape = THREE.SceneUtils.createMultiMaterialObject( 
		new THREE.TorusKnotGeometry( 30, 6, 160, 10, 3, 2 ), [ colorMaterial, wireMaterial ] );
	shape.position.set(200, 50, -200);
	scene.add( shape );

	// torus knot
	var colorMaterial = new THREE.MeshPhongMaterial( { color: 0xffff33 } );
	var shape = THREE.SceneUtils.createMultiMaterialObject( 
		new THREE.TorusKnotGeometry( 30, 6, 160, 10, 4, 3 ), [ colorMaterial, wireMaterial ] );
	shape.position.set(150, 150, 200);
	scene.add( shape );

	// torus knot
	var colorMaterial = new THREE.MeshPhongMaterial( { color: 0x3333ff } );
	var shape = THREE.SceneUtils.createMultiMaterialObject( 
		new THREE.TorusKnotGeometry( 30, 6, 160, 10, 3, 4 ), [ colorMaterial, wireMaterial ] );
	shape.position.set(-200, 50, 200);
	scene.add( shape );

	// final version of camera texture, used in scene. 
	var planeGeometry = new THREE.BoxGeometry( 800, 800, 1, 1 );
	backRenderTarget = new THREE.WebGLRenderTarget( 1024, 1024, { format: THREE.RGBFormat } );
	var planeMaterial = new THREE.MeshBasicMaterial( { map: backRenderTarget } );

    backRenderTarget.wrapS = THREE.RepeatWrapping;
    backRenderTarget.repeat.x = - 1;
    plane = new THREE.Mesh( planeGeometry, planeMaterial );
    plane.applyMatrix(new THREE.Matrix4().makeScale(1, 1, 1));
    plane.position.set(0,0,-401);
	scene.add(plane);

    // final version of camera texture, used in scene.
	var planeGeometry = new THREE.BoxGeometry( 800, 800, 1, 1 );
	bottomRenderTarget = new THREE.WebGLRenderTarget( 1024, 1024, { format: THREE.RGBFormat } );
	var planeMaterial = new THREE.MeshBasicMaterial( { map: bottomRenderTarget } );

    bottomRenderTarget.wrapS = THREE.RepeatWrapping;
    bottomRenderTarget.repeat.x = - 1;
    plane = new THREE.Mesh( planeGeometry, planeMaterial );
    plane.applyMatrix(new THREE.Matrix4().makeScale(1, 1, 1));
    plane.position.set(0,-401,0);
    plane.rotation.x = Math.PI/2;
    plane.rotation.z = -Math.PI/2;
	scene.add(plane);

    // final version of camera texture, used in scene.
	var planeGeometry = new THREE.BoxGeometry( 800, 800, 1, 1 );
	leftRenderTarget = new THREE.WebGLRenderTarget( 1024, 1024, { format: THREE.RGBFormat } );
	var planeMaterial = new THREE.MeshBasicMaterial( { map: leftRenderTarget } );

    leftRenderTarget.wrapS = THREE.RepeatWrapping;
    leftRenderTarget.repeat.x = - 1;
    plane = new THREE.Mesh( planeGeometry, planeMaterial );
    plane.applyMatrix(new THREE.Matrix4().makeScale(1, 1, 1));
    plane.position.set(-401,0,0);
    plane.rotation.y = Math.PI/2;
	scene.add(plane);

    //back backing
	var planeGeometry = new THREE.BoxGeometry( 820, 820, 1, 1 );
	var planeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000,  transparent: true, opacity: 0.7  } );
	var planeborder = new THREE.Mesh( planeGeometry, planeMaterial );
	planeborder.position.set(0,0,-402);
	scene.add(planeborder);

    //bottom backing
    planeGeometry = new THREE.BoxGeometry( 820, 820, 1, 1 );
    planeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000,  transparent: true, opacity: 0.7  } );
    planeborder = new THREE.Mesh( planeGeometry, planeMaterial );
	planeborder.position.set(0,-402,0);
    planeborder.rotation.x = Math.PI/2;
	scene.add(planeborder);

    //left backing
    planeGeometry = new THREE.BoxGeometry( 820, 820, 1, 1 );
    planeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000,  transparent: true, opacity: 0.7  } );
    planeborder = new THREE.Mesh( planeGeometry, planeMaterial );
	planeborder.position.set(-402,0,0);
    planeborder.rotation.y = Math.PI/2;
	scene.add(planeborder);

    //front backing
    planeGeometry = new THREE.BoxGeometry( 820, 820, 1, 1 );
    planeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000,  transparent: true, opacity: 0.7  } );
    planeborder = new THREE.Mesh( planeGeometry, planeMaterial );
	planeborder.position.set(0,0,402);
//	scene.add(planeborder);

    //right backing
    planeGeometry = new THREE.BoxGeometry( 820, 820, 1, 1 );
    planeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000,  transparent: true, opacity: 0.7  } );
    planeborder = new THREE.Mesh( planeGeometry, planeMaterial );
	planeborder.position.set(402,0,0);
    planeborder.rotation.y = Math.PI/2;
//	scene.add(planeborder);

    //top backing
    planeGeometry = new THREE.BoxGeometry( 820, 820, 1, 1 );
    planeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000,  transparent: true, opacity: 0.7  } );
    planeborder = new THREE.Mesh( planeGeometry, planeMaterial );
	planeborder.position.set(0,402,0);
    planeborder.rotation.x = Math.PI/2;
//	scene.add(planeborder);

    controls = new THREE.OrbitControls( mainCamera );
    controls.userRotate = true;
    controls.enabled = true;
	
}
function animate() 
{
    requestAnimationFrame( animate );
	render();
	update();
}
function update()
{
	var delta = clock.getDelta(); // seconds.
}
function render() 
{
    controls.update();


    gridXZ.visible = true;
    gridXY.visible = true;
    gridYZ.visible = true;

	// put the result of frontCamera into the first texture.
	renderer.render( scene, backCamera, backRenderTarget, true );
	renderer.render( scene, bottomCamera, bottomRenderTarget, true );
    renderer.render( scene, leftCamera, leftRenderTarget, true );
//    renderer.render( screenScene, screenCamera, bottomRenderTarget, true );
//    renderer.render( screenScene, screenCamera, finalRenderTarget, true );

	// render the main scene


    gridXZ.visible = false;
    gridXY.visible = false;
    gridYZ.visible = false;
	renderer.render( scene, mainCamera );
}
</script>

</body>
</html>