<!doctype html>
<html lang="en">
<head>
	<title>Camera Texture (Three.js)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<!--<link rel=stylesheet href="css/base.css"/>-->
</head>
<body>

<!--<script src="libs/experiment/Three.js"></script>-->
<script src="libs/three/three.min.js"></script>

<script src="libs/three/threex.basiclighting.js"></script>
<script src="libs/three/OrbitControls.js"></script>

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>

// standard global variables
var container, scene, renderer, controls, stats;
var clock = new THREE.Clock();

// custom global variables
var MovingCube, plane;
var backCamera, mainCamera;

// intermediate scene for reflecting the reflection
var screenScene, screenCamera, firstRenderTarget, newRenderTarget, finalRenderTarget;
init();
animate();
// FUNCTIONS 		
function init() 
{
	// SCENE
	scene = new THREE.Scene();
	// CAMERAS
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 10, FAR = 20000;

	// camera 1
	mainCamera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR );
	scene.add(mainCamera);
	mainCamera.position.set(0,200,500);
	mainCamera.lookAt(scene.position);

	// camera 2
	backCamera = new THREE.OrthographicCamera(
		window.innerWidth  / -2, window.innerWidth  /  2,
		window.innerHeight /  2, window.innerHeight / -2,
		10, 800 );

    backCamera.up.set(0, 1, 0);
    backCamera.position.set(0,0, -400);
	backCamera.lookAt(scene.position);
	scene.add(backCamera);

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setClearColor( 0xf0f0f0 );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
//    renderer.sortObjects = false;
//    renderer.shadowMapEnabled = true;
    renderer.shadowMapType = THREE.PCFShadowMap;

	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	// EVENTS

    // creating scene light
    var lighting = new THREEx.ThreePointsLighting();
    scene.add(lighting);

	// FLOOR
    var axes = new THREE.AxisHelper(300);
    scene.add( axes );

    var gridXZ = new THREE.GridHelper(400, 100);
    gridXZ.setColors( new THREE.Color(0x006600), new THREE.Color(0x006600) );
    gridXZ.position.set( 0,0,0 );
    scene.add(gridXZ);
	////////////
	// CUSTOM //
	////////////
	
	// create an array with six textures for a cool cube
    var cubeGeometry = new THREE.BoxGeometry( 50, 50, 50 );
    var cubeMaterial = new THREE.MeshPhongMaterial( { color:0xff0000 } );
    MovingCube = new THREE.Mesh( cubeGeometry, cubeMaterial );
	MovingCube.position.set(0, 0, 0);
	scene.add( MovingCube );	
	
	// a little bit of scenery...
//	var ambientlight = new THREE.AmbientLight(0x111111);
//	scene.add( ambientlight );
	var wireMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: false, transparent: false } );

	// torus knot
	var colorMaterial = new THREE.MeshPhongMaterial( { color: 0xff3333 } );
	var shape = THREE.SceneUtils.createMultiMaterialObject( 
		new THREE.TorusKnotGeometry( 30, 6, 160, 10, 2, 5 ), [ colorMaterial, wireMaterial ] );
	shape.position.set(-150, 150, -200);
	scene.add( shape );

	// torus knot
	var colorMaterial = new THREE.MeshPhongMaterial( { color: 0x33ff33 } );
	var shape = THREE.SceneUtils.createMultiMaterialObject( 
		new THREE.TorusKnotGeometry( 30, 6, 160, 10, 3, 2 ), [ colorMaterial, wireMaterial ] );
	shape.position.set(200, 50, -200);
	scene.add( shape );

	// torus knot
	var colorMaterial = new THREE.MeshPhongMaterial( { color: 0xffff33 } );
	var shape = THREE.SceneUtils.createMultiMaterialObject( 
		new THREE.TorusKnotGeometry( 30, 6, 160, 10, 4, 3 ), [ colorMaterial, wireMaterial ] );
	shape.position.set(150, 150, 200);
	scene.add( shape );

	// torus knot
	var colorMaterial = new THREE.MeshPhongMaterial( { color: 0x3333ff } );
	var shape = THREE.SceneUtils.createMultiMaterialObject( 
		new THREE.TorusKnotGeometry( 30, 6, 160, 10, 3, 4 ), [ colorMaterial, wireMaterial ] );
	shape.position.set(-200, 50, 200);
	scene.add( shape );
	
	// intermediate scene.
	//   this solves the problem of the mirrored texture by mirroring it again.
	//   consists of a camera looking at a plane with the mirrored texture on it. 
	screenScene = new THREE.Scene();
	
	screenCamera = new THREE.OrthographicCamera( 
		window.innerWidth  / -2, window.innerWidth  /  2, 
		window.innerHeight /  2, window.innerHeight / -2, 
		0, 800 );
	screenCamera.position.z = 1;
	screenScene.add( screenCamera );


//    var reflectMatrix = new THREE.Matrix4(  1, 0, 0, 0,
//                                            0, 1, 0, 0,
//                                            0, 0, -1, 0,
//                                            0, 0, 0, 1);
				
	var screenGeometry = new THREE.PlaneBufferGeometry( window.innerWidth, window.innerHeight );
	firstRenderTarget = new THREE.WebGLRenderTarget( 1024, 1024, { format: THREE.RGBFormat } );
	var screenMaterial = new THREE.MeshBasicMaterial( { map: firstRenderTarget } );
    var quad = new THREE.Mesh( screenGeometry, screenMaterial );
	screenScene.add( quad );


	// final version of camera texture, used in scene. 
	var planeGeometry = new THREE.BoxGeometry( 800, 800, 1, 1 );
	finalRenderTarget = new THREE.WebGLRenderTarget( 1024, 1024, { format: THREE.RGBFormat } );
	var planeMaterial = new THREE.MeshBasicMaterial( { map: finalRenderTarget } );

    finalRenderTarget.wrapS = THREE.RepeatWrapping;
    finalRenderTarget.repeat.x = - 1;
    planeGeometry.applyMatrix(new THREE.Matrix4().makeScale(1, 1, 1));

    plane = new THREE.Mesh( planeGeometry, planeMaterial );
    plane.position.set(0,0,-401);

	scene.add(plane);

    //back backing
	var planeGeometry = new THREE.BoxGeometry( 820, 820, 1, 1 );
	var planeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000,  transparent: true, opacity: 0.7  } );
	var planeborder = new THREE.Mesh( planeGeometry, planeMaterial );
	planeborder.position.set(0,0,-402);
	scene.add(planeborder);

    //bottom backing
    planeGeometry = new THREE.BoxGeometry( 820, 820, 1, 1 );
    planeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000,  transparent: true, opacity: 0.5  } );
    planeborder = new THREE.Mesh( planeGeometry, planeMaterial );
	planeborder.position.set(0,-402,0);
    planeborder.rotation.x = Math.PI/2;
	scene.add(planeborder);

    //left backing
    planeGeometry = new THREE.BoxGeometry( 820, 820, 1, 1 );
    planeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000,  transparent: true, opacity: 0.5  } );
    planeborder = new THREE.Mesh( planeGeometry, planeMaterial );
	planeborder.position.set(-402,0,0);
    planeborder.rotation.y = Math.PI/2;
	scene.add(planeborder);

    //front backing
    planeGeometry = new THREE.BoxGeometry( 820, 820, 1, 1 );
    planeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000,  transparent: true, opacity: 0.5  } );
    planeborder = new THREE.Mesh( planeGeometry, planeMaterial );
	planeborder.position.set(0,0,402);
//	scene.add(planeborder);

    //right backing
    planeGeometry = new THREE.BoxGeometry( 820, 820, 1, 1 );
    planeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000,  transparent: true, opacity: 0.5  } );
    planeborder = new THREE.Mesh( planeGeometry, planeMaterial );
	planeborder.position.set(402,0,0);
    planeborder.rotation.y = Math.PI/2;
//	scene.add(planeborder);

    //top backing
    planeGeometry = new THREE.BoxGeometry( 820, 820, 1, 1 );
    planeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000,  transparent: true, opacity: 0.5  } );
    planeborder = new THREE.Mesh( planeGeometry, planeMaterial );
	planeborder.position.set(0,402,0);
    planeborder.rotation.x = Math.PI/2;
//	scene.add(planeborder);

    controls = new THREE.OrbitControls( mainCamera );
    controls.userRotate = true;
    controls.enabled = true;
	
}
function animate() 
{
    requestAnimationFrame( animate );
	render();
	update();
}
function update()
{
	var delta = clock.getDelta(); // seconds.
}
function render() 
{
    controls.update();

	// put the result of frontCamera into the first texture.
	renderer.render( scene, backCamera, firstRenderTarget, true );
    renderer.render( screenScene, screenCamera, finalRenderTarget, true );

	// render the main scene
	renderer.render( scene, mainCamera );
}
</script>

</body>
</html>