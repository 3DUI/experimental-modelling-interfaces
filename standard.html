<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>Standard Interface</title>

    <!--initial favicon-->
    <link id="favicon" rel="icon" type="image/png" href="images/cube.png" />

    <!--styles-->
    <link href="libs/bootstrap/bootstrap.min.css" rel="stylesheet">
    <link href="libs/font-awesome.min.css" rel="stylesheet">

    <link href="css/style.css" rel="stylesheet">

</head>
<body id="bodyclass">

    <div class="main-container">
        <div id="ThreeJS"></div>
    </div>
    <div class="">
        <div id="reset" class="">
            <a class="btn btn-primary" onclick="reset()">Reset</a>
        </div>
        <div id="perspective" class=" label">
            Perspective View
        </div>
        <div id="top" class="label">
            Top (XZ) View
        </div>
        <div id="front" class=" label">
            Front (YZ) View
        </div>
        <div id="side" class=" label">
            Side (XY) View
        </div>
    </div>


</body>

    <!--scripts-->
    <script src="libs/jquery-1.11.3.min.js"></script>
    <script src="libs/bootstrap/bootstrap.min.js"></script>
    <script src="libs/three/three.min.js"></script>
    <script src="libs/three/standardControls.js"></script>
    <script src="libs/three/threex.basiclighting.js"></script>
    <script src="libs/three/droid_sans_regular.typeface.js"></script>

    <script>

        // global attributes needed for scene
        var container = document.getElementById( 'ThreeJS' );

        var camera, controls, scene, renderer;
        var objects = [], plane;
        var raycaster = new THREE.Raycaster();
        var gridXY, gridXZ, gridYZ;
        var mouse = new THREE.Vector2(),
        offset = new THREE.Vector3(),
        INTERSECTED, SELECTED, CURRENTCAM, CURRENTVIEW;

        var mouseX = 0, mouseY = 0;

        var views = [
                {
                    name: "perspective",
					left: 0,
					bottom: 0.5,
					width: 0.5,
					height: 0.5,
					background: new THREE.Color("#cecece"),
					eye: [ 1000, 1000, 1000 ],
					up: [ 0, 1, 0 ],
					fov: 45,
                    camera : new THREE.PerspectiveCamera( this.fov, window.innerWidth / window.innerHeight, 1, 10000 ),
				}
                ,
                {
                    name: "top",
					left: 0,
					bottom: 0,
					width: 0.5,
					height: 0.5,
					background: new THREE.Color("#cecece"),
					eye: [ 0, 1000, 0 ],
					up: [ 0, 1, 0 ],
					fov: 45,
                    camera : new THREE.OrthographicCamera(window.innerWidth / -1, window.innerWidth / 1, window.innerHeight / 1, window.innerHeight / -1, 1, 10000 ),
				}
                ,
				{
                    name: "front",
					left: 0.5,
					bottom: 0,
					width: 0.5,
					height: 0.5,
					background: new THREE.Color("#cecece"),
					eye: [ 0, 0, 1000 ],
					up: [ 0, 1, 0  ],
					fov: 45,
                    camera : new THREE.OrthographicCamera(window.innerWidth / -1, window.innerWidth / 1, window.innerHeight / 1, window.innerHeight / -1, 1, 10000 ),
				}
                ,
				{
                    name: "side",
					left: 0.5,
					bottom: 0.5,
					width: 0.5,
					height: 0.5,
					background: new THREE.Color("#cecece"),
					eye: [ 1000, 0, 0 ],
					up: [ 0, 1, 0 ],
					fov: 45,
                    camera : new THREE.OrthographicCamera(window.innerWidth / -1, window.innerWidth / 1, window.innerHeight / 1, window.innerHeight / -1, 1, 10000 ),
				}
			];

        function setupLabels(){
            var persLabel = document.getElementById("perspective");
            var topLabel = document.getElementById("top");
            var frontLabel = document.getElementById("front");
            var sideLabel = document.getElementById("side");
            var reset = document.getElementById("reset");

            persLabel.style.cssText = "left: 0px; top: 0px";
            reset.style.cssText = "left: 0px; top: 0px";
            topLabel.style.cssText = "left: 0px; top: " + window.innerHeight/2 + "px";
            frontLabel.style.cssText = "left: " + window.innerWidth/2 + "px; top: 0px";
            sideLabel.style.cssText = "left: " + window.innerWidth/2 + "px; top: " + window.innerHeight/2 + "px";
        }

        function setupViews(){
                for (var ii =  0; ii < views.length; ++ii ) {
					var view = views[ii];
					view.camera.position.x = view.eye[ 0 ];
					view.camera.position.y = view.eye[ 1 ];
					view.camera.position.z = view.eye[ 2 ];
					view.camera.up.x = view.up[ 0 ];
					view.camera.up.y = view.up[ 1 ];
					view.camera.up.z = view.up[ 2 ];
                    view.camera.zoom = 1;


                    controls = new THREE.OrbitControls( view.camera, container );
                    controls.userPan = true;
                    controls.userZoom = true;
                    controls.maxDistance = 8000;
                    controls.minDistance = 500;
                    view.controls = controls;
				}
            }

        init();
        animate();

        function reset(){
            setupViews();
        }

        function init() {

            setupLabels();

            scene = new THREE.Scene();
            scene.add( new THREE.AmbientLight( 0x505050 ) );

            setupViews();

            // creating scene light
        var lighting = new THREEx.ThreePointsLighting();
        scene.add(lighting);

            gridXZ = new THREE.GridHelper(400, 100);
            gridXZ.setColors( new THREE.Color(0x006600), new THREE.Color(0x006600) );
            gridXZ.position.set( 0,0,0 );
            scene.add(gridXZ);

            gridXY = new THREE.GridHelper(400, 100);
            gridXY.position.set( 0,0,0 );
            gridXY.rotation.x = Math.PI/2;
            gridXY.setColors( new THREE.Color(0x000066), new THREE.Color(0x000066) );
            scene.add(gridXY);

            gridYZ = new THREE.GridHelper(400, 100);
            gridYZ.position.set( 0,0,0 );
            gridYZ.rotation.z = Math.PI/2;
            gridYZ.setColors( new THREE.Color(0x660000), new THREE.Color(0x660000) );
            scene.add(gridYZ);


            var axes = new THREE.AxisHelper(300);
            scene.add( axes );

            // add 3D text
            var letters = ["A", "B", "C", "D", "E"];

            for(var i = 0; i < letters.length; i++){
                var materialFront = new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } );
                var textGeom = new THREE.TextGeometry( letters[i],
                {
                    size: 150, height: 20, curveSegments: 20,
                    font: "droid sans", weight: "normal", style: "normal",
                    bevelThickness: 5, bevelSize: 5, bevelEnabled: true,
                    material: 0, extrudeMaterial: 1
                });

                var object = new THREE.Mesh(textGeom, materialFront );
                object.position.x = Math.random() * 1000 - 500;
                object.position.y = Math.random() * 600 - 300;
                object.position.z = Math.random() * 800 - 400;
                object.rotation.x = Math.random() * 2 * Math.PI;
                object.rotation.y = Math.random() * 2 * Math.PI;
                object.rotation.z = Math.random() * 2 * Math.PI;
                object.castShadow = true;
                object.receiveShadow = true;
                scene.add( object );
                objects.push( object );
            }

            plane = new THREE.Mesh(
                new THREE.PlaneBufferGeometry( 10000, 10000, 0, 0 ),
                new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.25, transparent: true } )
            );
            plane.visible = false;
            scene.add( plane );


				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.sortObjects = false;
				renderer.shadowMapEnabled = true;
				renderer.shadowMapType = THREE.PCFShadowMap;
				container.appendChild( renderer.domElement );

				renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
				renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
				renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
				//
				window.addEventListener( 'resize', onWindowResize, false );
			}
        function animate() {
				requestAnimationFrame( animate );
				render();
			}
        function render() {

            for ( var ii = 0; ii < views.length; ++ii ) {
                gridXY.visible = true;
                gridYZ.visible = true;

                if(ii == 0){
                    gridXY.visible = false;
                    gridYZ.visible = false;
                }

                view = views[ii];
                camera = view.camera;
                view.controls.update();

                var left   = Math.floor( window.innerWidth  * view.left );
                var bottom = Math.floor( window.innerHeight * view.bottom );
                var width  = Math.floor( window.innerWidth  * view.width );
                var height = Math.floor( window.innerHeight * view.height );

                renderer.setViewport( left, bottom, width, height );
                renderer.setScissor( left, bottom, width-1, height-1 );
                renderer.enableScissorTest ( true );
                renderer.setClearColor( view.background );
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.render( scene, camera );
            }
        }

        function onWindowResize() {
            for ( var ii = 0; ii < views.length; ++ii ) {
                view = views[ii];
                camera = view.camera;
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.left = window.innerWidth*-1;
                camera.right = window.innerWidth;
                camera.top = window.innerHeight;
                camera.bottom = window.innerHeight*-1;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }
                    setupLabels();

        }

        function onDocumentMouseMove( event ) {
				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;


                views[0].controls.enabled = false;
                views[1].controls.enabled = false;
                views[2].controls.enabled = false;
                views[3].controls.enabled = false;

                if(mouse.x < 0 && mouse.y > 0){
                    CURRENTVIEW = 0;
                    mouse.x += 0.5;
                    mouse.y -= 0.5;
                }
                //top
                else if(mouse.x < 0 && mouse.y < 0){
                    CURRENTVIEW = 1;
                    mouse.x += 0.5;
                    mouse.y += 0.5;
                }
                //front
                else if(mouse.x > 0 && mouse.y < 0){
                    CURRENTVIEW = 2;

                    mouse.x -= 0.5;
                    mouse.y += 0.5;
                }
                //side
                else if(mouse.x > 0 && mouse.y > 0){
                    CURRENTVIEW = 3;
                    mouse.x -= 0.5;
                    mouse.y -= 0.5;
                }
                mouse.x*=2;
                mouse.y*=2;

                views[CURRENTVIEW].controls.enabled = true;
                CURRENTCAM = views[CURRENTVIEW].camera;
//                console.log(CURRENTCAM.zoom);

				raycaster.setFromCamera( mouse, CURRENTCAM );
				if ( SELECTED ) {
					var intersects = raycaster.intersectObject( plane );
                    if(intersects.length > 0){
					    SELECTED.position.copy( intersects[ 0 ].point.sub( offset ) );
                    }
                    else{
                        onDocumentMouseUp();
                    }
					return;
				}
				var intersects = raycaster.intersectObjects( objects );
				if ( intersects.length > 0 ) {
					if ( INTERSECTED != intersects[ 0 ].object ) {
						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

                        INTERSECTED = intersects[ 0 ].object;
                        INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                        INTERSECTED.material.emissive.setHex( 0x666666 );

						plane.position.copy( INTERSECTED.position);
                        plane.lookAt( CURRENTCAM.position );


                        if(CURRENTVIEW == 1){
                            plane.rotation.x = Math.PI/2;
                            plane.rotation.y = Math.PI;
                            plane.rotation.z = Math.PI;
                        }
                        else if(CURRENTVIEW == 2){
                            plane.rotation.x = Math.PI;
                            plane.rotation.y = Math.PI;
                            plane.rotation.z = Math.PI;
                        }
                        else if(CURRENTVIEW == 3){
                            plane.rotation.x = Math.PI;
                            plane.rotation.y = Math.PI/2;
                            plane.rotation.z = Math.PI;
                        }
                        else if (CURRENTVIEW == 0){
//                            plane.rotation.x = -Math.PI/4;
//                            plane.rotation.y = Math.PI/4;
//                            plane.rotation.z = Math.PI/6;

                        }
//                        console.log(plane.rotation.z);

					}
					container.style.cursor = 'pointer';
				} else {
					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;
					container.style.cursor = '-webkit-grab';
				}
			}
        function onDocumentMouseDown( event ) {
            event.preventDefault();
            raycaster.setFromCamera( mouse, CURRENTCAM );
            var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {
					views[CURRENTVIEW].controls.enabled = false;
					SELECTED = intersects[ 0 ].object;
					var intersects = raycaster.intersectObject( plane );
					offset.copy( intersects[ 0 ].point ).sub( plane.position );
					container.style.cursor = 'move';
				}
			}
        function onDocumentMouseUp( event ) {
//				event.preventDefault();
				views[CURRENTVIEW].controls.enabled = true;
				if ( INTERSECTED ) {
					plane.position.copy( INTERSECTED.position );
					SELECTED = null;
				}
				container.style.cursor = '-webkit-grab';
			}


    </script>


</html>