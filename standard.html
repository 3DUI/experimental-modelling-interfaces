<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>Standard Interface</title>

    <!--initial favicon-->
    <link id="favicon" rel="icon" type="image/png" href="images/cube.png" />

    <!--styles-->
    <link href="libs/bootstrap/bootstrap.min.css" rel="stylesheet">
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet">

</head>
<body>
    <div class="container">
        <div class="row">
            <div class="col-lg-10 col-lg-offset-1">
                <div id="perspective" class=" label">
                    Perspective View
                </div>
                <div id="top" class="label">
                    Top (XZ) View
                </div>
                <div id="front" class=" label">
                    Side (YZ) View
                </div>
                <div id="side" class=" label">
                    Front (XY) View
                </div>
                <div id="canvas-container" style="margin: 0 auto; text-align: center"></div>
            </div>
        </div>
    </div>

        <div id="reset" class="">
            <a class="btn btn-primary" onclick="reset()">Reset</a>
        </div>

    <!--scripts-->
    <script src="libs/jquery-1.11.3.min.js"></script>
    <script src="libs/bootstrap/bootstrap.min.js"></script>
    <script src="libs/three/three.min.js"></script>
    <script src="libs/three/threex.basiclighting.js"></script>
    <script src="libs/three/droid_sans_regular.typeface.js"></script>

    <script src="scripts/cameraControls.js"></script>
    <script src="scripts/objectControls.js"></script>
    <script src="scripts/interface.js"></script>


    <script>

        // global attributes needed for scene
        var container = document.getElementById( 'canvas-container' );
        var camera, controls, scene, renderer;
        var objects = [], movementPlane;
        var gridXY, gridXZ, gridYZ;
        var mouse = new THREE.Vector2();
        var offset = new THREE.Vector3();
        var INTERSECTED, SELECTED, CURRENTCAM, CURRENTVIEW;

        var OBJSTATE = { NONE: -1, ROTATE: 0, MOVE: 2 };
	    var objstate = OBJSTATE.NONE;
        var selectedEdge;


        var views = [
            {
                name: "perspective",
                left: 0,
                bottom: 0.5,
                width: 0.5,
                height: 0.5,
                background: new THREE.Color("#cecece"),
                eye: [ 1000, 1000, 1000 ],
                up: [ 0, 1, 0 ],
                fov: 45,
                camera : new THREE.PerspectiveCamera( this.fov, container.offsetWidth / container.offsetHeight, 1, 10000 )
            }
            ,
            {
                name: "top",
                left: 0,
                bottom: 0,
                width: 0.5,
                height: 0.5,
                background: new THREE.Color("#cecece"),
                eye: [ 0, 1000, 0 ],
                up: [ 0, 1, 0 ],
                fov: 45,
                camera : new THREE.OrthographicCamera(container.offsetWidth / -1, container.offsetWidth, container.offsetHeight, container.offsetHeight / -1, 1, 10000 )
            }
            ,
            {
                name: "front",
                left: 0.5,
                bottom: 0,
                width: 0.5,
                height: 0.5,
                background: new THREE.Color("#cecece"),
                eye: [ 0, 0, 1000 ],
                up: [ 0, 1, 0  ],
                fov: 45,
                camera : new THREE.OrthographicCamera(container.offsetWidth / -1, container.offsetWidth, container.offsetHeight, container.offsetHeight / -1, 1, 10000 )
            }
            ,
            {
                name: "side",
                left: 0.5,
                bottom: 0.5,
                width: 0.5,
                height: 0.5,
                background: new THREE.Color("#cecece"),
                eye: [ 1000, 0, 0 ],
                up: [ 0, 1, 0 ],
                fov: 45,
                camera : new THREE.OrthographicCamera(container.offsetWidth / -1, container.offsetWidth, container.offsetHeight, container.offsetHeight / -1, 1, 10000 )
            }
        ];

        function setupLabels(){
            var persLabel = document.getElementById("perspective");
            var topLabel = document.getElementById("top");
            var frontLabel = document.getElementById("front");
            var sideLabel = document.getElementById("side");
            var reset = document.getElementById("reset");

            persLabel.style.cssText = "left: 0px; top: 0px";
            reset.style.cssText = "left: 0px; top: 0px";
            topLabel.style.cssText = "left: 0px; top: " + container.offsetHeight/2 + "px";
            frontLabel.style.cssText = "left: " + container.offsetWidth/2 + "px; top: 0px";
            sideLabel.style.cssText = "left: " + container.offsetWidth/2 + "px; top: " + container.offsetHeight/2 + "px";
        }

        function setupViews(){
            for (var ii =  0; ii < views.length; ++ii ) {
                var view = views[ii];
                view.camera.position.x = view.eye[ 0 ];
                view.camera.position.y = view.eye[ 1 ];
                view.camera.position.z = view.eye[ 2 ];
                view.camera.up.x = view.up[ 0 ];
                view.camera.up.y = view.up[ 1 ];
                view.camera.up.z = view.up[ 2 ];
                view.camera.zoom = 1;

                controls = new THREE.OrbitControls( view.camera, container );
                controls.maxDistance = 8000;
                controls.minDistance = 500;
                view.controls = controls;
            }
        }


        init();
        animate();

        function reset(){
            setupViews();
        }

        function init() {

            setupInterface();

            setupLabels();

            setupViews();

            // add 3D text
            var letters = ["A", "B", "C", "D", "E"];

            for(var i = 0; i < letters.length; i++){
                var materialFront = new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } );
                var textGeom = new THREE.TextGeometry( letters[i],
                {
                    size: 150, height: 20, curveSegments: 20,
                    font: "droid sans", weight: "normal", style: "normal",
                    bevelThickness: 5, bevelSize: 5, bevelEnabled: true,
                    material: 0, extrudeMaterial: 1
                });

                var object = new THREE.Mesh(textGeom, materialFront );
                object.position.x = Math.random() * 1000 - 500;
                object.position.y = Math.random() * 600 - 300;
                object.position.z = Math.random() * 800 - 400;
                object.rotation.x = Math.random() * 2 * Math.PI;
                object.rotation.y = Math.random() * 2 * Math.PI;
                object.rotation.z = Math.random() * 2 * Math.PI;
                object.castShadow = true;
                object.receiveShadow = true;
                scene.add( object );
                objects.push( object );
            }

        }

        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {

            for ( var ii = 0; ii < views.length; ++ii ) {
                gridXY.visible = true;
                gridYZ.visible = true;

                if(ii == 0){
                    gridXY.visible = false;
                    gridYZ.visible = false;
                }

                var view = views[ii];
                camera = view.camera;
                view.controls.update();

                var left   = Math.floor( container.offsetWidth  * view.left );
                var bottom = Math.floor( container.offsetHeight * view.bottom );
                var width  = Math.floor( container.offsetWidth  * view.width );
                var height = Math.floor( container.offsetHeight * view.height );

                renderer.setViewport( left, bottom, width, height );
                renderer.setScissor( left, bottom, width-1, height-1 );
                renderer.enableScissorTest ( true );
                renderer.setClearColor( view.background );
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.render( scene, camera );
            }
        }

        function onWindowResize() {
            for ( var ii = 0; ii < views.length; ++ii ) {
                var view = views[ii];
                camera = view.camera;
                camera.aspect = container.offsetWidth / container.offsetHeight;
                camera.left = container.offsetWidth*-1;
                camera.right = container.offsetWidth;
                camera.top = container.offsetHeight;
                camera.bottom = container.offsetHeight*-1;
                camera.updateProjectionMatrix();
                renderer.setSize( container.offsetWidth, container.offsetHeight );
            }
            setupLabels();
        }

        function onDocumentMouseMove( event ) {
            event.preventDefault();

            mouse = cursorPositionInCanvas( renderer.domElement, event );

            views[0].controls.enabled = false;
            views[1].controls.enabled = false;
            views[2].controls.enabled = false;
            views[3].controls.enabled = false;

            var planeLookAt = new THREE.Vector3();

            if(mouse.x < 0 && mouse.y > 0){
                CURRENTVIEW = 0;
            }
            //top
            else if(mouse.x < 0 && mouse.y < 0){
                CURRENTVIEW = 1;
                planeLookAt.set(Math.PI/2, Math.PI, Math.PI);

            }
            //side
            else if(mouse.x > 0 && mouse.y < 0){
                CURRENTVIEW = 2;
                planeLookAt.set(Math.PI, Math.PI, Math.PI);
            }
            //front
            else if(mouse.x > 0 && mouse.y > 0){
                CURRENTVIEW = 3;
                planeLookAt.set(Math.PI, Math.PI/2, Math.PI);
            }
            mouse.x += (-1 * Math.sign(mouse.x)) * 0.5;
            mouse.y += (-1 * Math.sign(mouse.y)) * 0.5;

            mouse.x*=2;
            mouse.y*=2;

            views[CURRENTVIEW].controls.enabled = true;
            CURRENTCAM = views[CURRENTVIEW].camera;


            var raycaster = new THREE.Raycaster();
            raycaster.setFromCamera( mouse, CURRENTCAM );

            if(objstate === OBJSTATE.MOVE){
                if ( SELECTED ) {
                    intersects = raycaster.intersectObject( movementPlane );
                    if(intersects.length > 0){
                        SELECTED.position.copy( intersects[ 0 ].point.sub( offset ) );
                    }
                    else{
                        onDocumentMouseUp();
                    }
                    return;
                }
            }
            else if(objstate === OBJSTATE.ROTATE){

            }
            else if ( objstate === OBJSTATE.NONE )
            {
                var intersects = raycaster.intersectObjects( objects );
                if ( intersects.length > 0 ) {
                    if ( INTERSECTED != intersects[ 0 ].object ) {
                        scene.remove(selectedEdge);

                        INTERSECTED = intersects[ 0 ].object;
                        selectedEdge = new THREE.EdgesHelper(INTERSECTED, 0xffffff );
                        scene.add(selectedEdge);

                        movementPlane.position.copy( INTERSECTED.position);
                        movementPlane.lookAt( CURRENTCAM.position );

                        if(CURRENTVIEW != 0){
                            movementPlane.rotation.set(planeLookAt.x, planeLookAt.y, planeLookAt.z);
                        }
                    }
                    container.style.cursor = 'pointer';
                }
                else {
                    INTERSECTED = null;
                    container.style.cursor = '-webkit-grab';
                    scene.remove(selectedEdge);
                }
            }

        }

        function lockControls( ) {
            views[CURRENTVIEW].controls.enabled = false;
        }

        function releaseControls( ) {
            views[CURRENTVIEW].controls.enabled = true;
        }


    </script>

</body>
</html>